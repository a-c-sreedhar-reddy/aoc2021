// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Utils = require("./Utils.bs.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function duplicateBoard(board) {
  return board.map(function (row) {
              return row.map(function (a) {
                          return a;
                        });
            });
}

function findUnMarkedNumberPosition(board, number) {
  return board.reduce((function (acc, row, rowIndex) {
                if (acc !== undefined) {
                  return acc;
                }
                var index = Belt_Array.getIndexBy(row, (function (element) {
                        if (element.TAG === /* Marked */0) {
                          return false;
                        } else {
                          return element._0 === number;
                        }
                      }));
                if (index !== undefined) {
                  return [
                          rowIndex,
                          index
                        ];
                } else {
                  return acc;
                }
              }), undefined);
}

function getColumn(board, index) {
  return board.map(function (row) {
              return Caml_array.get(row, index);
            });
}

function allElementsAreMarked(row) {
  return row.every(function (element) {
              if (element.TAG === /* Marked */0) {
                return true;
              } else {
                return false;
              }
            });
}

function allRowElementsAreMarked(board, row) {
  return allElementsAreMarked(Caml_array.get(board, row));
}

function allColumnElementsAreMarked(board, column) {
  return allElementsAreMarked(getColumn(board, column));
}

function drawNumber(board, number) {
  var numberPosition = findUnMarkedNumberPosition(board, number);
  if (numberPosition === undefined) {
    return /* NotYetBingo */1;
  }
  var col = numberPosition[1];
  var row = numberPosition[0];
  Caml_array.set(Caml_array.get(board, row), col, {
        TAG: /* Marked */0,
        _0: number
      });
  if (allElementsAreMarked(Caml_array.get(board, row)) || allElementsAreMarked(getColumn(board, col))) {
    return /* Bingo */0;
  } else {
    return /* NotYetBingo */1;
  }
}

function sumOfunMarkedElements(board) {
  return board.reduce((function (acc, row) {
                return acc + row.reduce((function (acc, element) {
                              if (element.TAG === /* Marked */0) {
                                return acc;
                              } else {
                                return acc + element._0 | 0;
                              }
                            }), 0) | 0;
              }), 0);
}

var Board = {
  duplicateBoard: duplicateBoard,
  findUnMarkedNumberPosition: findUnMarkedNumberPosition,
  getColumn: getColumn,
  allElementsAreMarked: allElementsAreMarked,
  allRowElementsAreMarked: allRowElementsAreMarked,
  allColumnElementsAreMarked: allColumnElementsAreMarked,
  drawNumber: drawNumber,
  sumOfunMarkedElements: sumOfunMarkedElements
};

var inputLines = Utils.getInputLines("src/input/Day04.txt");

var numbers = Caml_array.get(inputLines, 0).split(",").map(function (i) {
      return Belt_Option.getWithDefault(Belt_Int.fromString(i), 0);
    });

var boards = [];

var numberOfBoards = (inputLines.length - 1 | 0) / 6 | 0;

function parseRow(str) {
  return Belt_Array.map(str.split(" ").filter(function (a) {
                  return a !== "";
                }), (function (i) {
                return {
                        TAG: /* UnMarked */1,
                        _0: Belt_Option.getWithDefault(Belt_Int.fromString(i), 0)
                      };
              }));
}

for(var i = 1; i <= numberOfBoards; ++i){
  var start = 2 + Math.imul(i - 1 | 0, 6) | 0;
  var board = [
      Caml_array.get(inputLines, start),
      Caml_array.get(inputLines, start + 1 | 0),
      Caml_array.get(inputLines, start + 2 | 0),
      Caml_array.get(inputLines, start + 3 | 0),
      Caml_array.get(inputLines, start + 4 | 0)
    ].map(parseRow);
  boards.push(board);
}

var Input = {
  inputLines: inputLines,
  numbers: numbers,
  boards: boards,
  numberOfBoards: numberOfBoards,
  parseRow: parseRow
};

var boardsForPart2 = boards.map(duplicateBoard);

var part1 = numbers.reduce((function (acc, number) {
        if (acc !== undefined) {
          return acc;
        }
        var bingoedBoardIndex = Belt_Array.getIndexBy(boards.map(function (board) {
                  return drawNumber(board, number);
                }), (function (status) {
                if (status) {
                  return false;
                } else {
                  return true;
                }
              }));
        if (bingoedBoardIndex === undefined) {
          return acc;
        }
        var unmarkedSum = sumOfunMarkedElements(Caml_array.get(boards, bingoedBoardIndex));
        return Math.imul(unmarkedSum, number);
      }), undefined);

var match = numbers.reduce((function (acc, number) {
        var boards = acc[0];
        if (!Belt_Option.isNone(acc[1])) {
          return acc;
        }
        var boardsStatus = boards.map(function (board) {
              return drawNumber(board, number);
            });
        if (boardsStatus.length === 1) {
          var match = boardsStatus[0];
          if (!match) {
            var unmarkedSum = sumOfunMarkedElements(Caml_array.get(boards, 0));
            return [
                    [],
                    Math.imul(unmarkedSum, number)
                  ];
          }
          
        }
        return [
                boards.filter(function (param, i) {
                      return Caml_array.get(boardsStatus, i) !== /* Bingo */0;
                    }),
                undefined
              ];
      }), [
      boardsForPart2,
      undefined
    ]);

var part2 = match[1];

console.log(part1);

console.log(part2);

exports.Board = Board;
exports.Input = Input;
exports.boards = boards;
exports.numbers = numbers;
exports.boardsForPart2 = boardsForPart2;
exports.part1 = part1;
exports.part2 = part2;
/* inputLines Not a pure module */
